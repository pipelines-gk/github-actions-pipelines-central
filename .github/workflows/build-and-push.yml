name: üöÄ Build and Push Docker Image

on:
  workflow_call:
    inputs:
      project_name:
        required: true
        type: string
      node_version:
        required: false
        default: "22"
        type: string
      workdir:
        required: false
        type: string
        default: "."
      dockerfile:
        required: false
        type: string
        default: "Dockerfile"
      enable_cache:
        required: false
        type: boolean
        default: true
    secrets:
      GH_TOKEN:
        required: true

permissions:
  contents: write
  packages: write
  actions: read
  pull-requests: write

concurrency:
  group: build-${{ inputs.project_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      DOCKER_BUILDKIT: "1"
      BUILDKIT_PROGRESS: plain

    steps:
      - name: üì¶ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 10
          token: ${{ secrets.GH_TOKEN }}

      - name: üß∞ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: npm
          cache-dependency-path: '${{ inputs.workdir }}/package-lock.json'

      - name: üß± Cache node_modules
        uses: actions/cache@v4
        id: cache-node-modules
        with:
          path: |
            ${{ inputs.workdir }}/node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ inputs.node_version }}-${{ hashFiles(format('{0}/package-lock.json', inputs.workdir)) }}
          restore-keys: |
            ${{ runner.os }}-node-${{ inputs.node_version }}-
            ${{ runner.os }}-node-

      - name: üì• Download files from 1Password artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.project_name }}-files
          path: ${{ inputs.workdir }}

      - name: üîç Verify .env file exists
        shell: bash
        run: |
          set -Eeuo pipefail
          WORKDIR="${{ inputs.workdir }}"
          ENV_PATH="$WORKDIR/.env"
          if [ "$WORKDIR" = "." ]; then ENV_PATH=".env"; fi
          if [ ! -f "$ENV_PATH" ]; then
            echo "::error title=.env missing::.env not found at $ENV_PATH"
            exit 1
          fi
          echo "‚úÖ Found $ENV_PATH"

      - name: üîë Process .env and export credentials
        shell: bash
        run: |
          set -Eeuo pipefail
          WORKDIR="${{ inputs.workdir }}"
          if [ "$WORKDIR" != "." ]; then cd "$WORKDIR"; fi

          DOCR_USERNAME="$(sed -n 's/^DOCR_USERNAME=\(.*\)$/\1/p' .env || true)"
          DOCR_PASSWORD="$(sed -n 's/^DOCR_PASSWORD=\(.*\)$/\1/p' .env || true)"

          if [ -z "${DOCR_USERNAME:-}" ]; then
            echo "::error title=Missing DOCR_USERNAME::Add DOCR_USERNAME to .env"
            exit 1
          fi
          if [ -z "${DOCR_PASSWORD:-}" ]; then
            echo "::error title=Missing DOCR_PASSWORD::Add DOCR_PASSWORD to .env"
            exit 1
          fi

          printf 'DOCR_USERNAME=%s\n' "$DOCR_USERNAME" >> "$GITHUB_ENV"
          printf 'DOCR_PASSWORD=%s\n' "$DOCR_PASSWORD" >> "$GITHUB_ENV"

          # Summary sin heredoc
          {
            printf '### üîê Credentials loaded\n' >> "$GITHUB_STEP_SUMMARY"
            printf -- '- DOCR_USERNAME and DOCR_PASSWORD exported to env.\n' >> "$GITHUB_STEP_SUMMARY"
          }

      - name: üè∑Ô∏è Release Please (version only)
        id: release_please
        uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          release-type: simple
          path: .
          skip-github-release: true
          skip-github-pull-request: true

      - name: üßÆ Compute base version
        id: compute_version
        shell: bash
        run: |
          set -Eeuo pipefail

          REL_TAG="${{ steps.release_please.outputs.tag_name }}"
          REL_VER="${{ steps.release_please.outputs.version }}"

          VERSION=""
          if [ -n "${REL_TAG:-}" ]; then
            VERSION="${REL_TAG#v}"
          elif [ -n "${REL_VER:-}" ]; then
            VERSION="${REL_VER#v}"
          else
            LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
            if [ -n "$LAST_TAG" ]; then
              VERSION="${LAST_TAG#v}"
              echo "‚ÑπÔ∏è No version from Release Please; using last tag: v$VERSION"
            else
              VERSION="0.0.0"
              echo "‚ÑπÔ∏è No tags found; starting from v0.0.0"
            fi
          fi

          echo "BASE_VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

          {
            printf '### üîñ Base version detected\n' >> "$GITHUB_STEP_SUMMARY"
            printf -- '- BASE_VERSION: v%s\n' "$VERSION" >> "$GITHUB_STEP_SUMMARY"
          }

      - name: üè∑Ô∏è Create Git tag with smart versioning
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -Eeuo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config --global advice.detachedHead false

          BASE_VERSION="${BASE_VERSION:-0.0.0}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"

          if [ "$BASE_VERSION" = "0.0.0" ]; then
            LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
            if [ -n "$LAST_TAG" ]; then
              IFS='.' read -r MAJOR MINOR PATCH <<< "${LAST_TAG#v}"
              echo "üß≠ Using last tag as base: v${MAJOR}.${MINOR}.${PATCH}"
            else
              echo "üß≠ No last tag, keep base v0.0.0"
            fi
          fi

          ALL_TAGS="$(git ls-remote --tags origin | awk '{print $2}' | sed 's|refs/tags/||' | grep -E "^v${MAJOR}\.${MINOR}\.[0-9]+$" || true)"

          if [ -z "$ALL_TAGS" ]; then
            FINAL_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          else
            MAX_PATCH="$(echo "$ALL_TAGS" | sed -E "s|^v${MAJOR}\.${MINOR}\.([0-9]+)$|\\1|" | sort -n | tail -1)"
            if [ -z "$MAX_PATCH" ]; then MAX_PATCH=0; fi
            FINAL_VERSION="${MAJOR}.${MINOR}.$((MAX_PATCH + 1))"
          fi

          echo "üßÆ Computed version: v${FINAL_VERSION}"

          for i in 1 2 3; do
            if git tag "v${FINAL_VERSION}" 2>/dev/null && git push origin "v${FINAL_VERSION}" 2>/dev/null; then
              echo "‚úÖ Tag created: v${FINAL_VERSION}"
              echo "VERSION=${FINAL_VERSION}" >> "$GITHUB_ENV"
              echo "version=${FINAL_VERSION}" >> "$GITHUB_OUTPUT"
              {
                printf '### üè∑Ô∏è Tag created\n' >> "$GITHUB_STEP_SUMMARY"
                printf -- '- New tag: v%s\n' "$FINAL_VERSION" >> "$GITHUB_STEP_SUMMARY"
              }
              exit 0
            fi

            git tag -d "v${FINAL_VERSION}" 2>/dev/null || true
            IFS='.' read -r M N P <<< "${FINAL_VERSION}"
            FINAL_VERSION="${M}.${N}.$((P + 1))"
            echo "‚ö†Ô∏è Tag collision, retrying with v${FINAL_VERSION} (attempt $i/3)"
            if [ $i -lt 3 ]; then sleep 1; fi
          done

          echo "::error title=Tagging failed::Failed to create tag after 3 attempts"
          exit 1
