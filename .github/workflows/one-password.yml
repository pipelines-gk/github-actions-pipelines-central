name: One Password

on:
  workflow_call:
    inputs:
      env_name_onepassword:
        required: true
        type: string
      project_name:
        required: true
        type: string
      vault_name:
        required: false
        type: string
        default: yclp7kgj7vku4d3wovopw2jabm
      files_path:
        required: false
        type: string
        default: 'csr_files'
    secrets:
      GH_TOKEN:
        required: true
      ONE_PASSWORD_SERVICE_ACCOUNT_TOKEN:
        required: true

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  prepare-one-password:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # ⬇️ 1. Install 1Password CLI v2 (Official Action - Much Faster)
      - name: Install 1Password CLI
        uses: 1password/install-cli-action@v1

      # ⬇️ 2. Fetch all fields from the item (env and certificates/keys) - ALWAYS FRESH
      - name: Fetch secrets from 1Password
        id: fetch-secrets
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.ONE_PASSWORD_SERVICE_ACCOUNT_TOKEN }}
          OP_CACHE: "false"
        run: |
          # Single API call to get the item as JSON (ALWAYS FRESH - NO CACHE)
          item_json=$(op item get "env-${{ inputs.env_name_onepassword }}" --vault "${{ inputs.vault_name }}" --format json)

          echo "🔍 DEBUG: Fields found in 1Password:"
          echo "$item_json" | jq -r '.fields[] | .label' || echo "Failed to parse fields"

          # Create temp upload directory and target directory for files
          mkdir -p _temp_upload
          if [ -n "${{ inputs.files_path }}" ]; then
            mkdir -p "_temp_upload/${{ inputs.files_path }}"
          fi

          # Process each field and save as file directly in _temp_upload
          # Filter out system fields (notesPlain, empty labels, etc.)
          echo "$item_json" | jq -r '.fields[] | select(.label != null and .label != "" and .label != "notesPlain" and .value != null and .value != "") | @json' | \
          while read -r field; do
            filename=$(echo "$field" | jq -r '.label')
            
            # Skip if filename is empty, invalid, or contains only whitespace
            if [ -z "$filename" ] || [[ "$filename" =~ ^[[:space:]]*$ ]]; then
              echo "⚠️ Skipping invalid filename"
              continue
            fi
            
            # .env always goes to root of _temp_upload, other files go to files_path
            if [ "$filename" = ".env" ]; then
              echo "⬇️ Saving $filename (root) to: _temp_upload/$filename"
              echo "$field" | jq -r '.value' > "_temp_upload/$filename"
              echo "✅ Saved! File size: $(wc -c < "_temp_upload/$filename") bytes"
            else
              if [ -n "${{ inputs.files_path }}" ]; then
                TARGET_PATH="_temp_upload/${{ inputs.files_path }}/"
              else
                TARGET_PATH="_temp_upload/"
              fi
              echo "⬇️ Saving $filename to: ${TARGET_PATH}${filename}"
              echo "$field" | jq -r '.value' > "${TARGET_PATH}${filename}"
              echo "✅ Saved! File size: $(wc -c < "${TARGET_PATH}${filename}") bytes"
            fi
          done
          
          echo ""
          echo "📦 Files to upload:"
          ls -laR _temp_upload/
          
          echo ""
          echo "🔍 Checking for .env specifically:"
          if [ -f "_temp_upload/.env" ]; then
            echo "✅ .env EXISTS in _temp_upload/"
            echo "Size: $(wc -c < "_temp_upload/.env") bytes"
            echo "First 3 lines:"
            head -n 3 "_temp_upload/.env"
          else
            echo "❌ .env NOT FOUND in _temp_upload/"
          fi

      # ⬇️ 4. Upload all files as artifact (with compression)
      - name: Upload All Files
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.project_name }}-files
          path: _temp_upload/
          retention-days: 1
          compression-level: 6
          if-no-files-found: error
